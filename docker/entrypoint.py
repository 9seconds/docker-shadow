#!/usr/bin/env python
# -*- coding: utf-8 -*-


import argparse
import urllib
import base64
import binascii
import functools
import json
import os
import sys


PATH_OWN_SETTINGS = "/etc/entry-settings.json"
PATH_SS_SETTINGS = "/etc/shadowsocks.json"
PATH_KCPTUN_SETTINGS = "/etc/kcptun.json"
PATH_SUPERVISORD_KCPTUN = "/etc/supervisor/supervisord.kcptun.conf"
PATH_SUPERVISORD_OBFS = "/etc/supervisor/supervisord.obfs.conf"
SHADOWSOCKS_REMOTE_PORT = 443
SHADOWSOCKS_TIMEOUT = 60
KCPTUN_REMOTE_PORT = 444


def settings_saved(func):
    @functools.wraps(func)
    def decorator(options):
        with open(PATH_OWN_SETTINGS, "wt") as fp:
            json.dump(options, fp)

        return func(options)

    return decorator


def settings_restored(func):
    @functools.wraps(func)
    def decorator(options):
        if not os.path.exists(PATH_OWN_SETTINGS):
            sys.exit("You need to run this command only on working container.")
        with open(PATH_OWN_SETTINGS, "rt") as fp:
            options = json.load(fp)

        return func(options)

    return decorator


def shadowsocks_env(func):
    @functools.wraps(func)
    def decorator(options):
        config = {
            "server": ["[::0]", "0.0.0.0"],
            "server_port": SHADOWSOCKS_REMOTE_PORT,
            "password": options["password"],
            "method": options["encryption_mode"],
            "timeout": 60,
            "user": "root",
            "fast_open": True,
            "reuse_port": True,
            "no_delay": True,
            "ipv6_first": True,
            "nameserver": options["nameserver"],
            "mode": "tcp_and_udp"
        }
        if options["command"] == "obfs":
            config.update({
                "plugin": "obfs-server",
                "plugin_opts": "obfs={0};failover={1}".format(
                    options["mode"], options["host"]
                )
            })
        elif options["command"] == "kcptun":
            # we do not want to expose shadowsocks anymore, only kcptun
            config["server"] = "127.0.0.1"

        with open(PATH_SS_SETTINGS, "wt") as fp:
            json.dump(config, fp)

        return func(options)

    return decorator


def kcptun_env(func):
    @functools.wraps(func)
    def decorator(options):
        config = {
            "listen": ":{0}".format(KCPTUN_REMOTE_PORT),
            "target": "127.0.0.1:{0}".format(SHADOWSOCKS_REMOTE_PORT),
            "crypt": "none",
            "mode": options["profile"],
            "mtu": options["mtu"],
            "sndwnd": options["sndwnd"],
            "rcvwnd": options["rcvwnd"],
            "datashard": options["datashard"],
            "parityshard": options["parityshard"],
            "dscp": options["dscp"],
            "nocomp": not options["compression"],
            "key": options["key"]
        }
        with open(PATH_KCPTUN_SETTINGS, "wt") as fp:
            json.dump(config, fp)

        return func(options)

    return decorator


def run_supervisord(func):
    @functools.wraps(func)
    def decorator(options):
        config_file, env = func(options)
        sys.stdout.flush()
        sys.stderr.flush()

        run_env = os.environ.copy()
        run_env.update(env)

        os.execlpe("supervisord", "supervisord", "-c", config_file, run_env)

    return decorator


def main():
    options = get_options()
    options = process_options(options)

    if options["command"] == "obfs":
        return run_obfs(options)
    elif options["command"] == "kcptun":
        return run_kcptun(options)
    elif options["command"] == "show":
        return run_show(options)
    else:
        return "Unknown command"


def get_options():
    parser = argparse.ArgumentParser(
        prog="shadowsocks",
        description="Run shadowsocks/kcptun with supervisord.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    parser.add_argument(
        "-p", "--server-port",
        type=int,
        default=443,
        help="Port to listen on."
    )
    parser.add_argument(
        "-k", "--password",
        help="Password to use. Default is autogenerated."
    )
    parser.add_argument(
        "-n", "--nameserver",
        default="1.1.1.1",
        help="Nameserver to use."
    )
    parser.add_argument(
        "-e", "--encryption_mode",
        choices=(
            "aes-128-gcm",
            "aes-192-gcm",
            "aes-256-gcm",
            "rc4-md5",
            "aes-128-cfb",
            "aes-192-cfb",
            "aes-256-cfb",
            "aes-128-ctr",
            "aes-192-ctr",
            "aes-256-ctr",
            "bf-cfb",
            "camellia-128-cfb",
            "camellia-192-cfb",
            "camellia-256-cfb",
            "chacha20-ietf-poly1305",
            "salsa20",
            "chacha20",
            "chacha20-ietf"
        ),
        default="chacha20-ietf-poly1305",
        help="Cipher to use."
    )
    parser.add_argument(
        "ip",
        help="IP address of ShadowSocks server (required for QR code)"
    )
    subparsers = parser.add_subparsers()

    obfs = subparsers.add_parser(
        "obfs",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="OBFS plugin settings."
    )
    obfs.set_defaults(command="obfs")
    obfs.add_argument(
        "-t", "--host",
        help="Hostname for obfuscating. Default is autogenerated."
    )
    obfs.add_argument(
        "mode",
        choices=("tls", "http"),
        default="tls",
        help="Which mode is to use for obfuscating."
    )

    kcptun = subparsers.add_parser(
        "kcptun",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="KCPTun plugin settings."
    )
    kcptun.set_defaults(command="kcptun")
    kcptun.add_argument(
        "-p", "--port",
        default=444,
        type=int,
        help="Default port to listen on"
    )
    kcptun.add_argument(
        "-r", "--profile",
        choices=(
            "normal",
            "fast",
            "fast2",
            "fast3"
        ),
        default="fast2",
        help="Profile to use with KCPTun."
    )
    kcptun.add_argument(
        "-t", "--mtu",
        type=int,
        default=1350,
        help="MTU for packets."
    )
    kcptun.add_argument(
        "-s", "--sndwnd",
        type=int,
        default=128,
        help="Send window in packets."
    )
    kcptun.add_argument(
        "-w", "--rcvwnd",
        type=int,
        default=512,
        help="Receive window in packets."
    )
    kcptun.add_argument(
        "-a", "--datashard",
        type=int,
        default=10,
        help="Reed-Solomon erasure coding - datashard"
    )
    kcptun.add_argument(
        "-d", "--parityshard",
        type=int,
        default=3,
        help="Reed-Solomon erasure coding - parityshard"
    )
    kcptun.add_argument(
        "-q", "--dscp",
        type=int,
        default=0,
        help="DSCP(6 bits)"
    )
    kcptun.add_argument(
        "-z", "--compression",
        action="store_true",
        default=False,
        help="Enable compression"
    )
    kcptun.add_argument(
        "-y", "--key",
        help="Key to work with KCPTun. Default is random generated."
    )

    show = subparsers.add_parser(
        "show",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        help="Show connection settings."
    )
    show.set_defaults(command="show")

    return parser.parse_args()


@settings_saved
@shadowsocks_env
@kcptun_env
@run_supervisord
def run_kcptun(options):
    env = {
        "KCPTUN_CONFIG_PATH": PATH_KCPTUN_SETTINGS,
        "SS_CONFIG_PATH": PATH_SS_SETTINGS
    }
    return PATH_SUPERVISORD_KCPTUN, env


@settings_saved
@shadowsocks_env
@run_supervisord
def run_obfs(options):
    env = {"SS_CONFIG_PATH": PATH_SS_SETTINGS}
    return PATH_SUPERVISORD_OBFS, env


@settings_restored
def run_show(options):
    base_url = make_sip002_url(options)
    qr_url = (
        "https://api.qrserver.com/v1/create-qr-code/?"
        "qzone=4&format=svg&data={0}"
    ).format(
        urllib.quote_plus(base_url)
    )
    print(
        json.dumps(
            {
                "url": base_url,
                "qr": qr_url
            },
            indent=4, sort_keys=True
        )
    )


def make_sip002_url(options):
    base = "{0}:{1}".format(options["encryption_mode"], options["password"])

    if options["command"] == "obfs":
        port = options["server_port"]
        plugin_name = "obfs-local"
        plugin_options = {
            "obfs": options["mode"],
            "obfs-host": options["host"]
        }
    else:
        port = options["port"]
        plugin_name = "kcptun"
        plugin_options = {
            "crypt": "none",
            "mode": options["profile"],
            "mtu": options["mtu"],
            "sndwnd": options["sndwnd"],
            "rcvwnd": options["rcvwnd"],
            "datashard": options["datashard"],
            "parityshard": options["parityshard"],
            "dscp": options["dscp"],
            "key": options["key"]
        }
        if not options["compression"]:
            plugin_options["nocomp"] = "true"

    plugin_options = plugin_name + ";" + ";".join(
        urllib.urlencode([(k, v)]) for k, v in plugin_options.items()
    )

    return "ss://{base}@{host}:{port}?plugin={plugin_options}".format(
        base=base64.urlsafe_b64encode(base).rstrip("="),
        host=options["ip"],
        port=port,
        plugin_options=urllib.quote_plus(plugin_options)
    )


def process_options(options):
    options = dict(options._get_kwargs())

    if options["command"] in ("kcptun", "obfs"):
        if not options["password"]:
            options["password"] = generate_password()
        if options["command"] == "kcptun" and not options["key"]:
            options["key"] = generate_password()
    elif options["command"] == "obfs" and not options["host"]:
        options["host"] = generate_random_url()

    return options


def generate_random_url():
    return "api.{0}.googleusercontent.com".format(
        binascii.hexlify(os.urandom(16))
    )


def generate_password():
    return base64.b64encode(os.urandom(16))


if __name__ == "__main__":
    sys.exit(main())
